package com.estoquecentral.inventory.application;

import com.estoquecentral.catalog.adapter.out.ProductRepository;
import com.estoquecentral.catalog.domain.Product;
import com.estoquecentral.inventory.adapter.out.InventoryMovementRepository;
import com.estoquecentral.inventory.adapter.out.InventoryRepository;
import com.estoquecentral.inventory.domain.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * InventoryService - Business logic for inventory management
 *
 * <p>Handles inventory operations with full audit trail:
 * <ul>
 *   <li>Add/remove stock with movement history</li>
 *   <li>Reserve/unreserve inventory</li>
 *   <li>Manual adjustments with reasons</li>
 *   <li>Low stock alerts</li>
 *   <li>Movement history tracking</li>
 * </ul>
 *
 * <p><strong>Story 3.1 scope:</strong> Basic inventory control for simple products.
 *
 * @see Inventory
 * @see InventoryMovement
 */
@Service
@Transactional
public class InventoryService {

    private final InventoryRepository inventoryRepository;
    private final InventoryMovementRepository movementRepository;
    private final ProductRepository productRepository;
    private final StockMovementService stockMovementService;

    private static final String DEFAULT_LOCATION = "DEFAULT";

    @Autowired
    public InventoryService(InventoryRepository inventoryRepository,
                            InventoryMovementRepository movementRepository,
                            ProductRepository productRepository,
                            StockMovementService stockMovementService) {
        this.inventoryRepository = inventoryRepository;
        this.movementRepository = movementRepository;
        this.productRepository = productRepository;
        this.stockMovementService = stockMovementService;
    }

    /**
     * Gets inventory for a product
     *
     * @param productId product ID
     * @param location location (null for DEFAULT)
     * @return optional inventory
     */
    @Transactional(readOnly = true)
    public Optional<Inventory> getInventory(UUID productId, String location) {
        String loc = location != null ? location : DEFAULT_LOCATION;
        return inventoryRepository.findByProductIdAndLocation(productId, loc);
    }

    /**
     * Gets inventory by ID
     *
     * @param id inventory ID
     * @return optional inventory
     */
    @Transactional(readOnly = true)
    public Optional<Inventory> getInventoryById(UUID id) {
        return inventoryRepository.findById(id);
    }

    /**
     * Gets all inventory records for a product (all locations)
     *
     * @param productId product ID
     * @return list of inventory records
     */
    @Transactional(readOnly = true)
    public List<Inventory> getAllInventoryForProduct(UUID productId) {
        return inventoryRepository.findAllByProductId(productId);
    }

    /**
     * Creates inventory record for a product
     *
     * @param tenantId tenant ID
     * @param productId product ID
     * @param initialQuantity initial quantity
     * @param location location (null for DEFAULT)
     * @param minQuantity minimum quantity threshold
     * @param maxQuantity maximum quantity threshold
     * @param userId user creating the inventory
     * @return created inventory
     */
    public Inventory createInventory(UUID tenantId, UUID productId, BigDecimal initialQuantity,
                                      String location, BigDecimal minQuantity, BigDecimal maxQuantity,
                                      UUID userId) {
        // Validate product exists and controls inventory
        Product product = productRepository.findByIdAndActive(productId)
                .orElseThrow(() -> new IllegalArgumentException("Product not found: " + productId));

        if (!product.shouldControlInventory()) {
            throw new IllegalArgumentException("Product does not control inventory: " + productId);
        }

        String loc = location != null ? location : DEFAULT_LOCATION;

        // Check if inventory already exists
        if (inventoryRepository.existsByProductIdAndLocation(productId, loc)) {
            throw new IllegalArgumentException(
                    "Inventory already exists for product " + productId + " at location " + loc);
        }

        // Create inventory
        Inventory inventory = new Inventory(tenantId, productId, initialQuantity, loc);
        inventory.setLevels(minQuantity, maxQuantity);
        inventory = inventoryRepository.save(inventory);

        // Create initial movement if quantity > 0
        if (initialQuantity.compareTo(BigDecimal.ZERO) > 0) {
            createMovement(
                    tenantId, productId, MovementType.IN, initialQuantity, loc,
                    BigDecimal.ZERO, initialQuantity,
                    MovementReason.INITIAL, "Initial inventory setup",
                    null, null, userId
            );
        }

        return inventory;
    }

    /**
     * Adds quantity to inventory (IN movement)
     *
     * @param productId product ID
     * @param quantity quantity to add
     * @param location location (null for DEFAULT)
     * @param reason reason for addition
     * @param notes additional notes
     * @param referenceType reference type (e.g., "PURCHASE_ORDER")
     * @param referenceId reference ID
     * @param userId user performing the operation
     * @return updated inventory
     */
    public Inventory addStock(UUID productId, BigDecimal quantity, String location,
                               MovementReason reason, String notes,
                               String referenceType, UUID referenceId, UUID userId) {
        validateQuantity(quantity);

        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = getOrCreateInventory(productId, loc);

        BigDecimal before = inventory.getQuantity();
        inventory.addQuantity(quantity);
        BigDecimal after = inventory.getQuantity();

        inventory = inventoryRepository.save(inventory);

        createMovement(
                inventory.getTenantId(), productId, MovementType.IN, quantity, loc,
                before, after, reason, notes, referenceType, referenceId, userId
        );

        return inventory;
    }

    /**
     * Removes quantity from inventory (OUT movement)
     *
     * @param productId product ID
     * @param quantity quantity to remove
     * @param location location (null for DEFAULT)
     * @param reason reason for removal
     * @param notes additional notes
     * @param referenceType reference type (e.g., "SALE")
     * @param referenceId reference ID
     * @param userId user performing the operation
     * @return updated inventory
     */
    public Inventory removeStock(UUID productId, BigDecimal quantity, String location,
                                  MovementReason reason, String notes,
                                  String referenceType, UUID referenceId, UUID userId) {
        validateQuantity(quantity);

        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = inventoryRepository.findByProductIdAndLocation(productId, loc)
                .orElseThrow(() -> new IllegalArgumentException("Inventory not found for product: " + productId));

        BigDecimal before = inventory.getQuantity();
        inventory.removeQuantity(quantity);
        BigDecimal after = inventory.getQuantity();

        inventory = inventoryRepository.save(inventory);

        createMovement(
                inventory.getTenantId(), productId, MovementType.OUT, quantity, loc,
                before, after, reason, notes, referenceType, referenceId, userId
        );

        return inventory;
    }

    /**
     * Adjusts inventory to specific quantity (ADJUSTMENT movement)
     *
     * @param productId product ID
     * @param newQuantity new quantity
     * @param location location (null for DEFAULT)
     * @param reason reason for adjustment
     * @param notes additional notes
     * @param userId user performing the operation
     * @return updated inventory
     */
    public Inventory adjustStock(UUID productId, BigDecimal newQuantity, String location,
                                  MovementReason reason, String notes, UUID userId) {
        if (newQuantity.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("New quantity cannot be negative");
        }

        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = inventoryRepository.findByProductIdAndLocation(productId, loc)
                .orElseThrow(() -> new IllegalArgumentException("Inventory not found for product: " + productId));

        BigDecimal before = inventory.getQuantity();
        inventory.adjustTo(newQuantity);
        BigDecimal after = inventory.getQuantity();

        // Calculate adjustment quantity (can be positive or negative)
        BigDecimal adjustmentQty = after.subtract(before);

        inventory = inventoryRepository.save(inventory);

        createMovement(
                inventory.getTenantId(), productId, MovementType.ADJUSTMENT, adjustmentQty.abs(), loc,
                before, after, reason, notes, null, null, userId
        );

        return inventory;
    }

    /**
     * Reserves quantity for order
     *
     * @param productId product ID
     * @param quantity quantity to reserve
     * @param location location (null for DEFAULT)
     * @param referenceType reference type (e.g., "ORDER")
     * @param referenceId reference ID
     * @param userId user performing the operation
     * @return updated inventory
     */
    public Inventory reserveStock(UUID productId, BigDecimal quantity, String location,
                                   String referenceType, UUID referenceId, UUID userId) {
        validateQuantity(quantity);

        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = inventoryRepository.findByProductIdAndLocation(productId, loc)
                .orElseThrow(() -> new IllegalArgumentException("Inventory not found for product: " + productId));

        BigDecimal reservedBefore = inventory.getReservedQuantity();
        inventory.reserve(quantity);
        BigDecimal reservedAfter = inventory.getReservedQuantity();

        inventory = inventoryRepository.save(inventory);

        createMovement(
                inventory.getTenantId(), productId, MovementType.RESERVE, quantity, loc,
                reservedBefore, reservedAfter,
                MovementReason.RESERVATION, "Stock reserved",
                referenceType, referenceId, userId
        );

        return inventory;
    }

    /**
     * Unreserves quantity (cancels reservation)
     *
     * @param productId product ID
     * @param quantity quantity to unreserve
     * @param location location (null for DEFAULT)
     * @param referenceType reference type (e.g., "ORDER")
     * @param referenceId reference ID
     * @param userId user performing the operation
     * @return updated inventory
     */
    public Inventory unreserveStock(UUID productId, BigDecimal quantity, String location,
                                     String referenceType, UUID referenceId, UUID userId) {
        validateQuantity(quantity);

        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = inventoryRepository.findByProductIdAndLocation(productId, loc)
                .orElseThrow(() -> new IllegalArgumentException("Inventory not found for product: " + productId));

        BigDecimal reservedBefore = inventory.getReservedQuantity();
        inventory.unreserve(quantity);
        BigDecimal reservedAfter = inventory.getReservedQuantity();

        inventory = inventoryRepository.save(inventory);

        createMovement(
                inventory.getTenantId(), productId, MovementType.UNRESERVE, quantity, loc,
                reservedBefore, reservedAfter,
                MovementReason.UNRESERVATION, "Stock unreserved",
                referenceType, referenceId, userId
        );

        return inventory;
    }

    /**
     * Fulfills reservation by removing from both quantity and reserved
     *
     * @param productId product ID
     * @param quantity quantity to fulfill
     * @param location location (null for DEFAULT)
     * @param referenceType reference type (e.g., "SALE")
     * @param referenceId reference ID
     * @param userId user performing the operation
     * @return updated inventory
     */
    public Inventory fulfillReservation(UUID productId, BigDecimal quantity, String location,
                                         String referenceType, UUID referenceId, UUID userId) {
        validateQuantity(quantity);

        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = inventoryRepository.findByProductIdAndLocation(productId, loc)
                .orElseThrow(() -> new IllegalArgumentException("Inventory not found for product: " + productId));

        BigDecimal before = inventory.getQuantity();
        inventory.fulfillReservation(quantity);
        BigDecimal after = inventory.getQuantity();

        inventory = inventoryRepository.save(inventory);

        createMovement(
                inventory.getTenantId(), productId, MovementType.OUT, quantity, loc,
                before, after, MovementReason.SALE, "Fulfilled reservation",
                referenceType, referenceId, userId
        );

        return inventory;
    }

    /**
     * Sets min/max quantity levels
     *
     * @param productId product ID
     * @param location location (null for DEFAULT)
     * @param minQuantity minimum quantity
     * @param maxQuantity maximum quantity
     * @return updated inventory
     */
    public Inventory setStockLevels(UUID productId, String location,
                                     BigDecimal minQuantity, BigDecimal maxQuantity) {
        String loc = location != null ? location : DEFAULT_LOCATION;
        Inventory inventory = inventoryRepository.findByProductIdAndLocation(productId, loc)
                .orElseThrow(() -> new IllegalArgumentException("Inventory not found for product: " + productId));

        inventory.setLevels(minQuantity, maxQuantity);
        return inventoryRepository.save(inventory);
    }

    /**
     * Gets products with low stock
     *
     * @return list of inventory records below minimum
     */
    @Transactional(readOnly = true)
    public List<Inventory> getLowStockProducts() {
        return inventoryRepository.findLowStockProducts();
    }

    /**
     * Gets products out of stock
     *
     * @return list of inventory records with zero available quantity
     */
    @Transactional(readOnly = true)
    public List<Inventory> getOutOfStockProducts() {
        return inventoryRepository.findOutOfStockProducts();
    }

    /**
     * Gets products with excess stock
     *
     * @return list of inventory records above maximum
     */
    @Transactional(readOnly = true)
    public List<Inventory> getExcessStockProducts() {
        return inventoryRepository.findExcessStockProducts();
    }

    /**
     * Gets movement history for a product
     *
     * @param productId product ID
     * @param pageable pagination parameters
     * @return page of movements
     */
    @Transactional(readOnly = true)
    public Page<InventoryMovement> getMovementHistory(UUID productId, Pageable pageable) {
        return movementRepository.findByProductIdOrderByCreatedAtDesc(productId, pageable);
    }

    /**
     * Gets recent movements
     *
     * @param pageable pagination parameters
     * @return page of recent movements
     */
    @Transactional(readOnly = true)
    public Page<InventoryMovement> getRecentMovements(Pageable pageable) {
        return movementRepository.findAllByOrderByCreatedAtDesc(pageable);
    }

    /**
     * Gets total inventory value
     *
     * @return total inventory value
     */
    @Transactional(readOnly = true)
    public Double getTotalInventoryValue() {
        return inventoryRepository.getTotalInventoryValue();
    }

    /**
     * Counts low stock products
     *
     * @return count of products below minimum
     */
    @Transactional(readOnly = true)
    public long countLowStockProducts() {
        return inventoryRepository.countLowStockProducts();
    }

    /**
     * Counts out of stock products
     *
     * @return count of products with zero available quantity
     */
    @Transactional(readOnly = true)
    public long countOutOfStockProducts() {
        return inventoryRepository.countOutOfStockProducts();
    }

    // ==================== Private Helper Methods ====================

    private Inventory getOrCreateInventory(UUID productId, String location) {
        Optional<Inventory> existing = inventoryRepository.findByProductIdAndLocation(productId, location);
        if (existing.isPresent()) {
            return existing.get();
        }

        // Auto-create inventory if not exists
        Product product = productRepository.findByIdAndActive(productId)
                .orElseThrow(() -> new IllegalArgumentException("Product not found: " + productId));

        if (!product.shouldControlInventory()) {
            throw new IllegalArgumentException("Product does not control inventory: " + productId);
        }

        Inventory inventory = new Inventory(product.getTenantId(), productId, BigDecimal.ZERO, location);
        return inventoryRepository.save(inventory);
    }

    private void createMovement(UUID tenantId, UUID productId, MovementType type,
                                BigDecimal quantity, String location,
                                BigDecimal quantityBefore, BigDecimal quantityAfter,
                                MovementReason reason, String notes,
                                String referenceType, UUID referenceId, UUID userId) {
        // Save to old InventoryMovement table (legacy)
        InventoryMovement movement = new InventoryMovement(
                tenantId, productId, type, quantity, location,
                quantityBefore, quantityAfter,
                reason, notes, referenceType, referenceId, userId
        );
        movementRepository.save(movement);

        // TODO: Integrate with new StockMovementService
        // This requires mapping location (String) to location_id (UUID)
        // For now, keeping both systems in parallel
        // Future: Remove InventoryMovement table and use only StockMovement
    }

    private void validateQuantity(BigDecimal quantity) {
        if (quantity == null || quantity.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
    }
}
